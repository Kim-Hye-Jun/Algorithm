이 문제는 배낭 알고리즘을 활용한다.
동전의 합이 입력받은 동전들의 total의 반값이 나오는지 안나오는지 묻는 문제이다.
부분 집합의 합 중에서 X이하의 최댓값이 X인지를 보면 되는 문제이다.

일차원 dp를 통해 풀 수 있다.
어떻게?
dp[N]이 1이면 N을 만들수 있음을
0이면 N을 만들 수 없음을 의미한다.

dp[0] = 1로 놓는다 
그 후 i를 K부터 0까지 돌면서 dp[i-coin[a]]이 1인 곳을 찾는다.
그 후 dp[i]를 1로 만들어준다.

(dp[i]가 1인곳을 찾고 i+coin[a]가 K이하인지 체크후 1로 만들어도 되지만 그러면 약간더 코드가 복잡해진다)

그리고 dp[K]를 반환해주면 된다.
가능하면 1 불가능하면 0이니 출력해주면 된다.

이 문제는 LIS, LIS추적을 할줄알면 풀수있다

LIS 는 배열을 앞에서부터 탐색하면서 
LIS벡터의 back와 비교해 크면 LIS뒤에 넣어주고
작으면 LIS 안에있는 원소중 자신보다 큰데 가장작은 수와 바꿔주면
LIS의 크기를 구할수있다.

추적을 하는 경우엔
1) LIS벡터의 back와 비교해보니 더 커서 LIS뒤에 넣어줄때
dp[i] = LIS.size()로 V의 원소를 LIS 넣었을때 자기가 얼마나큰 LIS를 만들수있는지 길이를
dp에 저장해둔다

2) 작아서 lower_bound값과 바꿔줄때도 마찬가지로
distance(LIS.begin(), it) +1 를 dp에 저장함으로써 자기가 얼마나큰 LIS길이를 만드는지 저장한다

3) 저장할때 가장큰 dp값(가장 길게 LIS를 만들었을때 마지막에 오는 값의 인덱스 번호를 알아야하니까)
을 max에 인덱스번호를 max_N에 저장해둔다

그 후 저장된 dp를 max_N부터 뒤로 탐색하는데
dp 값이 max , max-1 , max-2....인 인덱스를
ans벡터에 넣어두면 ans벡터로 LIS추적을 할수있다
(ans벡터에는 LIS의 거꾸로 된 배열이 들어가있다)

이렇게 LIS길이 LIS 원소를 구할수 있는데

전깃줄문제도 LIS와 같다
이어져있는 전깃줄이 앞에서부터 B전봇대번호가 늘어나야 겹치지 않기 때문이다.
그래서 전체 전깃줄을 set에 저장후
LIS번호를 구해 set.erase()를 해준 후
출력하면 된다.
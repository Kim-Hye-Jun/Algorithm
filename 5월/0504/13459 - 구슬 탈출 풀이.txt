구현하는데 신경을 많이 써야하는 문제이다.
그리고 4방향으로 기울이는데 4의 10제곱을 하면 약 1억정도 되니까 모든경우를 다해보면 시간 내에 풀 수 있다.

입력을 받고 R,B의 위치를 저장해놓고
arr.. 판에는 .으로 처리를 해놓는다.
그러면 훨씬 편하게 구현할 수 있다.

처음에 R,B를 계속 바꿔줘야하나...? 이런 생각에
구현하기 너무 복잡하다고 생각을 했는데
그냥 .으로 놓고 위치만 받아서 구현을 하는걸 보고
이렇게 하니까 훨씬 쉬웠다.


bfs로 접근을 하는데
일단 각각 좌우상하 로 움직이는 경우 각각 빨간구슬, 파란구슬의 위치를 queue에 넣어놓는다.
그러면 상하좌우 4번 다 움직일 경우 queue에 4개가 들어가게되겠지?
하지만 움직이다가 red marble이 먼저 빠지면 queue에 넣지 않고 넘긴다.

각 두 구슬이 움직이는건 while()문을 통해 움직이는 방향으로 움직이면 '.' 을 만나면 움직인다 (nextX+dx를 해준다)
언제까지?? 앞에 .이 없을 때까지

그리고 queue를 한번 비우고 나면 ( while(size= q.size()) ) ret(몇번 기울였는지?)값을 ++ 해준다
그렇게 10보다 커지면 return -1;

생각해야 할건	1) R,B가 동시에 빠지는 경우
		2) B먼저 빠지는 경우
		3) 기울였는데 같은 지점에서 만나는 경우

1),2) 의 경우 먼저 B가 빠졌다면 넘겨버리면서 ( continue ) 해결이 가능하다.
3) 의 경우 기울였는데 같은 지점에서 만났다? 그럼 더 적게 움직인 구슬이 먼저 도착했을테니 
	더 많이 움직인 구슬의 위치를 현재 움직이는 방향으로 한칸 빼주면 된다

이렇게 해도 정답처리가 되지만
queue에 nextX, nextY 위치를 넣을때
만약 전에 방문한적이 있는 위치라면 넣을 필요가 없다.
visit 이 true면 continue를 해주면 시간을 훨씬 줄일 수 있다.

이 코드를 넣었을 때 0ms
	안넣었을때 52ms

구현하는 문제를 많이 풀어봐야할것 같다.
이런 구슬탈출 문제들이 구현연습을 하기 좋은것 같다.